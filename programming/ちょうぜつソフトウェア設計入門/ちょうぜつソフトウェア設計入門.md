# ちょうぜつソフトウェア設計入門
- 田中ひさてる

# 1章
開発パフォーマンスを向上させる
アーキテクチャは動作に貢献しない
画面を操作するときに役に立たないが、作り続ける場合は役にたつ情報
汚いコードは意味を理解することに時間がかかり生産性を落とす

汚い設計の特徴
- デメリット1:まとまりが悪いため、いろんなところを治す必要がでてくる
- デメリット2:同じところに意味の違うものが混ざっていて壊れやすい
- 変更による影響を考える思考負荷が高い
- 求められている機能は小さいのに配慮する必要がある

汚い設計への機能追加「ごちゃごちゃしていててどこに片付ければいいかわからない、勝手に動かしたらダメそうだしそのままにしてとりあえず見えるところに置いておこう」

1.ドメインモデル：人がなんと言おうと事実な部分
2.ユースケース：人が何をしたいかの部分
3.インタフェースアダプタ：アプリケーションの枠作り
4.インフラストラクチャ：した支えとしての動作の実態

設計の答えは盲目的に従えば正しいと言えるものではない

### 凝集度
- 高いと影響規模がわかりやすいので見積もりしやすい

どうすれば綺麗になるか
- ひとつの関心がひとつの箇所に閉じている
- 利用する/される関係箇所を可能な限り減らす
- できるだけ変更頻度の高い事情に依存しない


凝集度、モジュール内の評価、結合度はモジュール間の相互依存性の度合い

# 7章 依存性注入
- テスト駆動開発ではうごくはずとわかった部品を手に入れた
- 依存性注入 (Dependency Injection)とは
  - オブジェクトが使う機能の実体をえる際、解決を自力で行わず、常に外部から与えるようにすべしという設計方針
  - 強い結合は扱いにくい
  - Fizzbuzzを例
  - パッケージを跨いで変更影響が及ぶことを避けたい
  - 単体テストは戻り値や呼び出すメソッドを検証するのを得意だがprintみたいに外部出力するものを確認するのは苦手
- 内部で各インスタンスを生成していた結合度の高いモジュールからインスタンス生成を追い出して責務を分離する
- これは電子工作でメーカーが別売りの各部品がそれぞれきちんと動作すると保証するかと、それらをどう買い集めて組み立てるかは、全く別のフェーズにあるという問題。
