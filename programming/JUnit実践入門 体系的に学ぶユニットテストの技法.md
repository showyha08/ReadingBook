# JUnit 実践入門 体系的に学ぶユニットテストの技法

# 読書目的

## 本を読む動機

- Unit テストの基本を学びたかった
- 業務で利用している JUnit5 をもっと理解したかった

JUnit5 を専門にした書籍が見つからなかった為、本書で代用することにした。
本書は JUnit4 を元に書かれており JUnit5 には対応していない、その為以下の通り読み進めた。

## 私の読み進め方

- JUnit5 の公式ドキュメントを開きながら読み進める
- JUnit4 から JUnit5 のドキュメントに書いてあることに置き換えて実際に試してみる

# 読書メモ

テストメソッドの作成

- テストクラスは public にする
- テストメソッドは org.junit.Test アノテーションを付与した publiic メソッドにする
- テストメソッドは戻り値が void、引数は持たない
- throws は自由に定義可能

ソフトウェアテストの特徴

- 特定の条件下にある
- ソフトウェアの振る舞いを記録できる
- 期待する結果と実際の結果を検証

用語

- テストケース ... 1 つのテスト項目のこと
- テストメソッド...テストケースの実装
- テストスイート ... テストケースをまとめたもの

ソフトウェアテストは製造業や建築業でのプロセスや考え方を取り入れている

製造業
だめなものは基本的に破棄されるので、設計と試作をしっかりやって問題が出ないようにする。

- 全数検査... 全部をチェックすること、大量生産するものは困難、コストがかかる
- 抜取り検査... 母集団からサンプリングして検査、このうち何％が不良かみる

建築
よっぽど特殊な建築物でない限りパターンが決まっている

- 一定の形式規格があり強度、価格、品質が予測できる
- 建築が始まると大きな手戻りが許されない
- 大きな負荷をかけて検証ができない

ソフトウェア開発
要求の変化が大きく作ってみなければわからないことが多い

- 規模や目的は多種多様、全く同じものはない
- 開発が始まっても壊して作り直しができる
- 負荷テストができる
- 設計と試作をしっかりやっても、コストが膨らむだけで品質に影響しない可能性がある。

ソフトウェアテストの目的

- 品質保証
- 設計時の考慮漏れが無いかを確認し、完成度を測る

テストの限界

- 完璧なテストはできない
  - Int なら 40 億のテストがほしいが、現実的では無い
- 十分なテストが求められる
  - 要求や予算に依存

テスト技法

- 境界値テスト
  - 境界値の近傍からテストデータを選択する
  - 例：20 歳以下の場合は割引:20、21 をテストする
  - プログラムの仕様の境界値付近でバグが生まれやすいという性質を利用したテスト
  - 例： if (age <= 20) というコードがあった場合に、不等号か比較する値を間違える可能性が高い
  - ブラックボックスとホワイトボックスの２つの特性をもつ
- 同値分割法(同値クラス分割)...出力結果が同じになる入力値の集合(同値パーティション)」を区分してテストを実行する。
  - 各グループを代表する値を１つテストケースに選ぶことにより、少ないテストケースで効率よくテストを実施できる
- 探索的テスト(事前・直前の結果に応じて、次のテストを施していく)など...

ソフトウェアテストの分類は大きく２つ

- ホワイトボックステスト...内部ロジックや仕様について考慮したテスト
- ブラックボックステスト...内部仕様を考慮せずに外部仕様からテストを作成、業務知識が必要

ユニットテスト

- クラスやメソッドを対象としたテスト
- ユニットテストはホワイトボックス寄り
  内部ロジックによりすぎると変更に脆いので外部仕様からのテストも必要

ユニットテスト特徴

- 成功する = プログラムとして実行できる仕様書ともなる
- テストコードを書いていて使いにくい、設計や仕様の問題に気づけることがある
- テストコードを書くのに工数はかかるが実行の工数は低い
- 繰り返し実行でき、半自動化、自動化も可能
  - 手動に比べてコストが低い

ユニットテストの目的

- レグレッション(デグレーション)を恐れずに改修できるのでデベロッパーテストとも呼ばれる
  - EC の秘伝のソースもこれさえあれば....
    - 既存のソースを変更しないように改修するのがベターになる
    - これが積み重なるとコードの保守性が落ち、非常に改修がやりずらくなる
  - レグレッション(回帰)テスト = デグレーション(劣化)テスト 同じ意味で使う
  - リリースして前の機能に影響したらデグレとかいうがレグレーションしたとは言わない。
  - ちなみに degration という英単語はないので注意！ 正確には degrade 。
- プロダクトコード書く前にクラスやメソッドの仕様をきめて、それを元にテストコードを先に書くのをテスト駆動という

ユニットテストのパターン

- 自動化...繰り返しいつでも実行できる
- 不安定なテストを避ける...常に成功する状態を維持、失敗しているものを放置しない
  - 放置すると他のテストが失敗しても気にしない状態になる(割れ窓理論)

実行環境は本番環境と近い方が良い

- OS の違いでの、セパレータ、パスの違いによるエラーなど
- 環境依存を避けられない場合、実行環境に依存しないコードを書く必要がある

問題の局所化

- 失敗時に問題を特定しやすいようにテストケースを小さくする

不明瞭なテスト

- 可読性の低いコードをさける
- 前提条件が同じのが二回現れたら@Befor を使う
- テストする実行は１つの操作にする
- 検証も 1 つのテストケースで１つだけが理想
- データクラスの検証は equals で見やすいが、失敗時のフィールド不一致箇所の特定に時間がかかるの
  - フィールドごとかカスタム Matcher を使う

実行順序に依存しないこと

- シングルトンで管理されている李ソールやデータベースにアクセルするテストだとおこりえる
- テスト終了処理では元の状態に戻すのが理想
- テストしやすい設計にするのも大事
  - ハードコーディングされた設定ファイルを読み込む
  - ミュータブルなオブジェクト定義だと起こり得る...

シングルトンとユニットテストの相性が悪い

- テストの独立性が損なわれる
  - 各テストでシングルトンオブジェクトが共有されるため
- シングルトンの場合、後処理を考慮しないといけない
- 並行テストが不安定になる
- シングルトンはコンストラクタを privatenisite,static メソッドからそのクラスのインスタンスを取得する

テスティングフレームワーク

- JUnit などのテストを支援するフレームワークのこと
  - xUnit フレームワークを利用。
  - smallTalk 用の SUnit を起源とした移植した

テストケース

- ある状況での入力をした時の結果の期待を記述したもの
- 重要なポイント
  - 前提条件
  - 入力値や操作
  - 期待する値や動作
- 「正しく表示されること」といった表現は避ける。正しくは読み手によって解釈が異なる。

テスト対象

- テスト対象となるクラスやオブジェクトを SUT ...System Under Test とよぶ
- SUT(System under test)は一つのテストケースで１つ、複数だとなんのテストか不明瞭となる
- sut という変数にインスタンスを格納すると良い
- actual 実測値、expected 期待値 という変数を使うと良い

メソッドと副作用

- ユニットテストを行いやすいクラス設計にする
  - メソッドが戻り値をもつ
  - メソッド呼び出しによる副作用がない(オブジェクトの内部のインスタンス変数等を変更しない)
  - 同じ状態、同じパラメータの実行で、同じ結果を返す
- 副作用もランダム性もないメソッドを関数的という

例：ArrayList の add は副作用があり、戻り値がない。size や get を使い間接的に確認するしかない。

4 フェーズテスト
テストコードは以下の様に分類する、コメントを書くと良い。

- 事前準備・・・SUT の初期化、必要な入力値、期待される結果などの準備
- 実行・・・テストする操作を一つだけ行う
- 検証・・・実測値と期待値を比較する
- あと処理・・・次のテストに影響がないようにする
  - ※ユニットテストにおいては利用シーンが少ない
  - JUnit ではテストメソッドの実行ごとにテストクラスのインスタンスが生成され終了時にインスタンス変数が破棄されるため
- Given-When-Then 構文

テストフィクスチャ

- テストメソッドに必要なデータや状態を指す
- ここが長くなるとテストがやりたいことがわかりにくくなる
  - フィクスチャの初期化が簡単 → セットアップに含める
  - 簡単ではない → 外部定義ファイルに記述、フィクスチャの初期化メソッドを外部クラスに定義するなど

アサーション(assertion、断言、主張、成立条件)

- テスト結果と期待値との検証の仕組み、宣言
- JUnit はこれを API で記述していく

アノテーション

- クラス、メソッドなどに補助的な情報を宣言するための機能（Java5 以降）
- JUnit では Test アノテーションでテストメソッドを認識させる
- isAnnotationPresent でアノテーションを探している

基本テストパターン

- 標準的な振る舞いを検証するテスト
- 例外の創出を検証する
- コンストラクタを検証する

fail

- 必ず失敗する
- 未実装の TODO を描くと良い

テストランナー

- テストケースの実行を制御できる仕組み
  - 特定のテストケース実行
  - テストケースの除外
- ５以降はテストランナーは JUnit エンジンに置き換わり不要になった

テストケースのグループ化

- メソッド単位でグループ化する
- 共通する初期化単位でグループ化する
  - こちらの方が良い
    - 初期化処理が共通なので見通しが良くなる
  - 共通のデータに着目
    - 例えば、テーブルが空の場合、100 件レコードがある場合で分ける
  - 共通の状態に着目
    - 例えば、ArrayList が空、2 件の場合
  - class ~の場合、method ~ を返す

テストフィクスチャ(フィクスチャ)

- テストで扱うデータやオブジェクト状態を指す
  - テスト対象オブジェクト
  - 実行に必要な入力値
  - 検証に必要な期待値
  - 実行に必要なオブジェクト操作
  - ファイルなどの外部リソース
  - データベースやソケットサーバなどの外部システム
  - 依存クラスや依存外部システムのモックオブジェクト
- フィクスチャのセットアップは長くなりがち
  - 可読性を高めるためにはここの工夫に力を入れる

フレッシュフィクスチャ

- ユニットテストでの戦略
  - フィクスチャはテストケースごとに独立する
  - テスト実行ごとに初期化する
  - 終了時には開放する
- ユニットテストの原則と相性が良い
  - テストケースは互いに独立し依存してはならない
- シングルトンで設計されたクラスやリソースはデータ共有せざるを得ないので注意

スローテスト問題

- データベーステスト、外部サービス通信を含む場合、セットアップに時間がかかる
- 目安として全ユニットテストで 10 分以上かかるなら問題が発生しているとみなす
- 対策
  - 並行実行... マルチスレッド、複数テスト環境で実行
  - 共有フィクスチャ...同一フィクスチャを共有してセットアップコストを削減。
    - 問題が多い。やるなら普遍オブジェクトにする。
  - カテゴリ化テスト...テストをグループ分けしてフィルタリング
  - テストを絞り込む
  - 実行環境を強化する
  - 実行時間を短くする

フィクスチャセットアップ

- 時間がかかる部分に用いる
- 暗黙的セットアップ... @before を使ったセットアップメソッドを使う
- 生成メソッド...複数のテストクラスで共通のセットアップを行う
- 外部リソースからのセットアップ...yaml,json.xml などを使う、外部ライブラリを利用して object に変換

テスタビリティ

- テストのしやすさ

ユニットテストのメリット

- 書いておくとリファクタリングがしやすい
- デグレの発生に気づける

テストダブル
依存するオブジェクトを置き換える手法

- モック(メソッドが呼び出されたことを確認する目的)、オブジェクトの相互作用に着目
- スタブ(予測が困難なテストに対して、仮実装で予測した値を返すようにする)、オブジェクトの状態に着目
- スパイ(副作用のあるメソッドのテストに対して、オリジナルのオブジェクトをラップする例：ログ出力など)

Mockito

- モック用のライブラリ
- モックはスタブの上位互換なので、スタブにもつかえる
- スパイもできる

Web 三層構造アーキテクチャ
- パーシステンス(Persistence:永続)層　データベースに直接アクセスする
- サービス層　ビジネスロジックを実装する
- プレゼンテーション層　入力値の検証やユーザーインターフェースを実装する

パーシステンス層をスタブ化する
メリット：データベースに依存しないため高速、
       :パーシステンス層のモジュールが未完成でもインタフェースさえ定義できればサービス層の実装を進められること

デメリット：データベースを使ってないと発生しない問題を検出できない

DbUnit
データベースに依存するクラスのユニットテストを行うためのJUnitの拡張ライブラリ
データセットはFlatXML,CSVなど外部定義にして読み込むと良い


MVC
- model 表示に関連しないすべての部分
- view 表示に関連する部分
- controller model と view の間の処理を行う

イベント駆動
- ユーザー操作やその他の条件等のイベントが発生したら、それに対応する処理を実行する
- コンポーネントとイベントを紐付けることをバインドという

イベントリスナ/イベントハンドラ
- ボタンなどにバインドされるクラスやメソッドのこと
- Androidなどのフレームワークは外部イベントを監視して、イベントを検知したらイベントハンドラを実行する
- イベントハンドラの実行を発火するという
- ボタンがイベントハンドラがコントローラに相当する

GUIアプリケーションのスレッドモデル
- GUIアプリケーションではGUIの描画とイベントをシングルスレッドで処理する
- このスレッドをGUIスレッドという
- イベント処理が長いと描画に時間がかかってしまう

シナリオテスト
- ユーザーの操作をシナリオとして記述し、それを実行するテスト
- ハッピーパス(正常系)をテストする
- 準正常系、異常系をテストする

コードカバレッジ(カバレッジ)
- テストコードがカバーしているプロダクションコードの割合
- C0,C1,C2がある
- C0は命令網羅、C1は分岐網羅、C2は条件網羅
  - C0はすべての命令の実行を1回以上実行されたかを判定する(ifはみない)
  - C1はすべての分岐(true,false)が実行されたかを判定する
  - C2はすべての条件が真偽値の組み合わせで実行されたかを判定する
    - C2に対応するツールがほとんどない
- カバレッジツールで計測すると良い
- 80 ~ 90 %％のカバレッジを目標にするプロジェクトが多い


---

## 以下雑記

### TODO

テスト suite
Enclosed 構造化テスト
テストの並列実行

### あとで読むべき

xUnit Test Patterns
https://qiita.com/hgsgtk/items/a3186a250d36d3b224
http://xunitpatterns.com/d9
https://xn--97-273ae6a4irb6e2hsoiozc2g4b8082p.com/

### 豆知識

jUnit4 の assertThat は消えた。代わりに assertJ を入れると良い。
他にも Hamcrest というアサーションライブラリがある
https://qiita.com/disc99/items/31fa7abb724f63602dc9

assertThat はメソッドチェーン(オブジェクトに対して.を繋げていく)
assertThat("hoge").isEqualTo("hoge")
